(()=>{"use strict";let e,t,n,r,i,a,o,s,c,f=[],l=!1,u=1,d={x:()=>0,y:()=>0,z:()=>3};class g{constructor(e,t,n,r){this.toAlignedArray=()=>[...this.p0,0,...this.p1,0,...this.p2,m(this.material)],this.p0=e,this.p1=t,this.p2=n,this.material=r}}class v{constructor(e,t,n){this.toAlignedArray=()=>[...this.center,this.radius,m(this.material),0,0,0],this.center=e,this.radius=t,this.material=n}}class h{constructor(e,t,n,r,i){this.toAlignedArray=()=>[...this.color,this.reflection,this.refraction,this.texture,this.emissive,0],this.color=e,this.reflection=t,this.refraction=n,this.texture=r,this.emissive=i}}function m(e){return Object.keys(p).indexOf(e)}const p={ground:new h([.3,.3,.3],0,0,0,0),glass:new h([1,1,1],1,1.5,-1,0),metal:new h([1,1,1],1,0,-1,0),roughtMetal:new h([1,1,1],.3,0,-1,0),solidIndigo:new h([.3,0,.5],0,0,-1,0),solidGreen:new h([0,1,0],0,0,-1,0),solidRed:new h([1,0,0],0,0,-1,0),solidBlue:new h([0,0,1],0,0,-1,0),solidYellow:new h([1,1,0],0,0,-1,0),solidWhite:new h([1,1,1],0,0,-1,0),cornellRed:new h([.65,.05,.05],0,0,-1,0),cornellGreen:new h([.12,.45,.15],0,0,-1,0),cornellWhite:new h([.73,.73,.73],0,0,-1,0),weakLight:new h([.2,.2,.2],0,0,-1,1),light:new h([10,10,10],0,0,-1,1),strongLight:new h([100,100,100],0,0,-1,1),glowOrange:new h([1.7,.6,.01],0,0,-1,1)},y=[new v([0,1.9,0],.02,"weakLight")],w=[new v([-.4,-.7,0],.3,"glass"),new v([.4,-.7,0],.3,"metal")],b=[new g([-1,1,1],[-1,-1,1],[-1,1,-1],"cornellGreen"),new g([-1,-1,1],[-1,-1,-1],[-1,1,-1],"cornellGreen"),new g([1,1,1],[1,1,-1],[1,-1,1],"cornellRed"),new g([1,-1,1],[1,1,-1],[1,-1,-1],"cornellRed"),new g([1,-1,-1],[1,1,-1],[-1,1,-1],"cornellWhite"),new g([-1,-1,-1],[1,-1,-1],[-1,1,-1],"cornellWhite"),new g([-1,-1,1],[1,-1,-1],[-1,-1,-1],"cornellWhite"),new g([1,-1,-1],[-1,-1,1],[1,-1,1],"cornellWhite"),new g([-1,1,1],[-1,1,-1],[1,1,-1],"cornellWhite"),new g([1,1,-1],[1,1,1],[-1,1,1],"cornellWhite")],M=[new g([-.3,.99,.3],[-.3,.99,-.3],[.3,.99,-.3],"weakLight"),new g([.3,.99,-.3],[.3,.99,.3],[-.3,.99,.3],"weakLight")];function x(){n.queue.writeBuffer(a.resolutionBuffer,0,new Float32Array([e.width,e.height])),n.queue.writeBuffer(a.cameraPosBuffer,0,new Float32Array([d.x(),d.y(),d.z()])),n.queue.writeBuffer(a.cameraLookAtBuffer,0,new Float32Array([0,0,0])),n.queue.writeBuffer(a.iterationBuffer,0,new Float32Array([u]));const s=n.createCommandEncoder(),c={colorAttachments:[{view:t.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},f=s.beginRenderPass(c);f.setPipeline(r),f.setBindGroup(0,i),f.draw(3,1,0,0),f.end(),s.copyTextureToTexture({texture:o.currentFrameBuffer},{texture:o.previousFrameBuffer},[e.width,e.height]),n.queue.submit([s.finish()])}function P(){l&&(_(),x()),requestAnimationFrame(P)}function _(){u++;let e=.001*Date.now();const t=1/(e-(f[0]||e))*f.length;f.push(e),f.length>60&&f.shift(),document.getElementById("fpsMeter").textContent=`${t.toFixed(2)} fps`,document.getElementById("iteration").textContent=`iteration: ${u}`}function C(e){throw new Error(e)}function S(){e.width=window.innerWidth,e.height=window.innerHeight,l||null==n||(_(),x())}function B(e){" "!=e.key&&"Space"!=e.code||(l=!l)}function L(e){"n"!=e.key&&"KeyN"!=e.code||(_(),x())}function U(e){"c"!=e.key&&"KeyC"!=e.code||(u=0,_(),x())}function T(e){const t={};return t.materials=e.createBuffer({size:32*Object.keys(p).length,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),t.spheres=e.createBuffer({size:32*w.length,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),t.sphereLights=e.createBuffer({size:32*y.length,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),t.triangles=e.createBuffer({size:48*b.length,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),t.triangleLights=e.createBuffer({size:48*M.length,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),t}window.addEventListener("load",(async function(){var f,l;const u=null!==(f=await navigator.gpu.requestAdapter())&&void 0!==f?f:C("no adapter");n=await u.requestDevice(),e=document.getElementById("canvas"),e.width=window.innerWidth,e.height=window.innerHeight,t=null!==(l=e.getContext("webgpu"))&&void 0!==l?l:C("no context"),await async function(){const f=navigator.gpu.getPreferredCanvasFormat();var l;t.configure({device:n,format:f,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),a={resolutionBuffer:(l=n).createBuffer({size:8,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),cameraPosBuffer:l.createBuffer({size:12,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),cameraLookAtBuffer:l.createBuffer({size:12,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),iterationBuffer:l.createBuffer({size:4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),...T(n)},o={previousFrameBuffer:n.createTexture({size:[e.width,e.height],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba32float"}),currentFrameBuffer:n.createTexture({size:[e.width,e.height],usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC,format:"rgba32float"})},s=o.previousFrameBuffer.createView(),c=o.currentFrameBuffer.createView();const u=n.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:3,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:4,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}},{binding:5,visibility:GPUShaderStage.FRAGMENT,storageTexture:{format:"rgba32float"}},{binding:6,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage",minBindingSize:0}},{binding:7,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage",minBindingSize:0}},{binding:8,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage",minBindingSize:0}},{binding:9,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage",minBindingSize:0}},{binding:10,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage",minBindingSize:0}}]});i=n.createBindGroup({layout:u,entries:[{binding:0,resource:{buffer:a.resolutionBuffer}},{binding:1,resource:{buffer:a.cameraPosBuffer}},{binding:2,resource:{buffer:a.cameraLookAtBuffer}},{binding:3,resource:{buffer:a.iterationBuffer}},{binding:4,resource:s},{binding:5,resource:c},{binding:6,resource:{buffer:a.materials}},{binding:7,resource:{buffer:a.spheres}},{binding:8,resource:{buffer:a.sphereLights}},{binding:9,resource:{buffer:a.triangles}},{binding:10,resource:{buffer:a.triangleLights}}]}),function(e){e.queue.writeBuffer(a.materials,0,new Float32Array(Object.values(p).flatMap((e=>e.toAlignedArray())))),e.queue.writeBuffer(a.spheres,0,new Float32Array(w.flatMap((e=>e.toAlignedArray())))),e.queue.writeBuffer(a.sphereLights,0,new Float32Array(y.flatMap((e=>e.toAlignedArray())))),e.queue.writeBuffer(a.triangles,0,new Float32Array(b.flatMap((e=>e.toAlignedArray())))),e.queue.writeBuffer(a.triangleLights,0,new Float32Array(M.flatMap((e=>e.toAlignedArray()))))}(n);const d=n.createPipelineLayout({bindGroupLayouts:[u]});r=n.createRenderPipeline({layout:d,vertex:{module:n.createShaderModule({code:"struct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn main(\n  @builtin(vertex_index) VertexIndex : u32\n) -> VertexOutput {\n  var pos = array<vec2<f32>, 3>(\n    vec2(-1.0, 1.0),\n    vec2(-1.0, -3.0),\n    vec2(3.0, 1.0)\n  );\n\n  var output : VertexOutput;\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n  output.fragPosition = .5 * (output.Position + vec4(1.0, 1.0, 1.0, 1.0));\n\n  return output;\n}\n"}),entryPoint:"main"},fragment:{module:n.createShaderModule({code:"const SAMPLES: i32 = 1;\nconst MAXBOUNCES: i32 = 8;\n\n@group(0) @binding(0) var<uniform> resolution : vec2f;\n@group(0) @binding(1) var<uniform> cameraPos : vec3f;\n@group(0) @binding(2) var<uniform> cameraLookAt : vec3f;\n@group(0) @binding(3) var<uniform> iteration : f32;\n@group(0) @binding(4) var previousFrame : texture_2d<f32>;\n@group(0) @binding(5) var currentFrame : texture_storage_2d<rgba32float, write>;\n@group(0) @binding(6) var<storage> materials : array<Material>;\n@group(0) @binding(7) var<storage> spheres : array<Sphere>;\n@group(0) @binding(8) var<storage> sphereLights : array<Sphere>;\n@group(0) @binding(9) var<storage> triangles : array<Triangle>;\n@group(0) @binding(10) var<storage> triangleLights : array<Triangle>;\n\n\n// ########### Constants ###########\n\nconst INFINITY: f32 = bitcast<f32>(0x7F7FFFFFu);\nconst EPSILON: f32 = 0.0001; // todo better definition\nconst PI: f32 = 3.1415926535897932384626433832795;\n\nvar<private> coordinates : vec2f;\n\n\n// ########### Structs ########### \n\nstruct Material {\n    color: vec3f,\n    reflection: f32,\n    refraction: f32,\n    texture: i32,\n    emissive: i32,\n};\n\nstruct Triangle {\n\tp0: vec3f,\n\tp1: vec3f,\n\tp2: vec3f,\n    material: f32,\n};\n\nstruct Sphere {\n    center: vec3f,\n    radius: f32,\n    material: f32,\n};\n\nstruct Ray {\n    origin: vec3f,\n    direction: vec3f,\n};\n\nstruct HitRecord {\n    position: vec3f,\n    normal: vec3f,\n    distance: f32,\n    u: f32,\t\t\t // texture coordinate\n    v: f32,\t\t\t // texture coordinate\n    frontFace: bool,\n    material: Material,\n};\n\n\n// ########### Scene ###########\n// Materials\n//\t\t\t\t\t\t\t\t\t\t \t\t\t   color        ,reflection,refraction,texture,emissive\nconst ground:       Material = Material(vec3f(  0.3,   0.3,   0.3),       0.0,       0.0,   0, 0);\nconst glass:        Material = Material(vec3f(  1.0,   1.0,   1.0),       1.0,       1.5,  -1, 0);\nconst metal:        Material = Material(vec3f(  1.0,   1.0,   1.0),       1.0,       0.0,  -1, 0);\nconst roughtMetal:  Material = Material(vec3f(  1.0,   1.0,   1.0),       0.3,       0.0,  -1, 0);\n\nconst solidIndigo:  Material = Material(vec3f(  0.3,   0.0,   0.5),       0.0,       0.0,  -1, 0);\nconst solidGreen:   Material = Material(vec3f(  0.0,   1.0,   0.0),       0.0,       0.0,  -1, 0);\nconst solidRed:     Material = Material(vec3f(  1.0,   0.0,   0.0),       0.0,       0.0,  -1, 0);\nconst solidBlue:    Material = Material(vec3f(  0.0,   0.0,   1.0),       0.0,       0.0,  -1, 0);\nconst solidYellow:  Material = Material(vec3f(  1.0,   1.0,   0.0),       0.0,       0.0,  -1, 0);\nconst solidWhite:   Material = Material(vec3f(  1.0,   1.0,   1.0),       0.0,       0.0,  -1, 0);\nconst cornellRed:   Material = Material(vec3f(  .65,  0.05,  0.05),         0,       0.0,  -1, 0);\nconst cornellGreen: Material = Material(vec3f(  .12,   .45,   .15),         0,       0.0,  -1, 0);\nconst cornellWhite: Material = Material(vec3f(  .73,   .73,   .73),         0,       0.0,  -1, 0);\n\nconst weakLight:    Material = Material(vec3f(  0.2,   0.2,   0.2),       0.0,       0.0,  -1, 1);\nconst light:        Material = Material(vec3f( 10.0,  10.0,  10.0),       0.0,       0.0,  -1, 1);\nconst strongLight:  Material = Material(vec3f(100.0, 100.0, 100.0),       0.0,       0.0,  -1, 1);\nconst glowOrange:   Material = Material(vec3f(  1.7,   0.6,  0.01),       0.0,       0.0,  -1, 1);\n\n\n// ########### Common functions ###########\n\nfn at(ray: Ray, t: f32) -> vec3f {\n\treturn ray.origin + t * ray.direction;\n}\n\n// random from 0 to 1\nfn rand(seed: f32) -> f32 {\n    return fract(sin(dot(vec2(seed, iteration) * coordinates, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfn randMM(seed: f32, min: f32, max: f32) -> f32 {\n    return min + (max - min) * rand(seed);\n}\n\nfn rand2MM(seed: f32, min: f32, max: f32) -> vec2f {\n    return vec2f( randMM(seed, min, max), randMM(seed * 4793.0, min, max));\n}\n\nfn rand3MM(seed: f32, min: f32, max: f32) -> vec3f {\n    return vec3f(randMM(seed, min, max), randMM(seed + 4789.0, min, max), randMM(seed + 7919.0, min, max));\n}\n\nfn rand2(seed: f32) -> vec2f {\n    return rand2MM(seed, 0.0, 1.0);\n}\n\nfn rand3(seed: f32) -> vec3f {\n    return rand3MM(seed, 0.0, 1.0);\n}\n\nfn random_in_unit_sphere(seed: f32) -> vec3f {\n\tvar rand = rand3(seed);\n\tvar ang1 = (rand.x + 1.0) * PI; // [-1..1) -> [0..2*PI)\n\tvar u = rand.y; // [-1..1), cos and acos(2v-1) cancel each other out, so we arrive at [-1..1)\n\tvar u2 = u * u;\n\tvar sqrt1MinusU2 = sqrt(1.0 - u2);\n\tvar x = sqrt1MinusU2 * cos(ang1);\n\tvar y = sqrt1MinusU2 * sin(ang1);\n\tvar z = u;\n\treturn vec3f(x, y, z);\n}\n\nfn random_unit_vector(seed: f32) -> vec3f {\n    return normalize(random_in_unit_sphere(seed));\n}\n\nfn random_in_hemisphere(normal: vec3f, seed: f32) -> vec3f {\n    var in_unit_sphere = random_in_unit_sphere(seed);\n    if (dot(in_unit_sphere, normal) > 0.0) {// In the same hemisphere as the normal\n        return in_unit_sphere;\n    } else {\n        return -in_unit_sphere;\n    }\n}\n\nfn random_in_triangle(seed: f32) -> vec2f {\n\tvar random2D = rand2(seed);\n\tif(random2D.x + random2D.y < 1){\n\t\treturn random2D;\n\t} else {\n\t\treturn vec2f(1) - random2D;\t\n\t};\n}\n\nfn random_in_specific_triangle(seed: f32, p0: vec3f, p1: vec3f, p2:vec3f) -> vec3f {\n\tvar randomHalf2D = random_in_triangle(seed);\n\tvar a = p1 - p0;\n\tvar b = p2 - p0;\n\tvar w = randomHalf2D.x * a + randomHalf2D.y * b;\n\treturn w + p0;\n}\n\n// ########### Raytracing functions ###########\n\nfn hitSphere(sphere: Sphere, ray: Ray, tMin: f32, tMax: f32, rec: ptr<function, HitRecord>) -> bool { // ? todo why function and not private pointer\n    var oc = ray.origin - sphere.center;\n    var a = dot(ray.direction, ray.direction);\n    var half_b = dot(oc, ray.direction);\n    var c = dot(oc, oc) - sphere.radius * sphere.radius;\n    var discriminant = half_b * half_b - a * c;\n\t\n\tif (discriminant < 0.0){\n        return false;\n    }\n\n\tvar sqrtd = sqrt(discriminant);\n\tvar root = (-half_b - sqrtd) / a;\n    if (root < tMin || tMax < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < tMin || tMax < root){\n            return false;\n        }\n    }\n\n\t(*rec).distance = root;\n\t(*rec).position = at(ray, (*rec).distance);\n\n\tvar outward_normal = ((*rec).position - sphere.center) / sphere.radius;\n\t(*rec).frontFace = dot(ray.direction, outward_normal) < 0.;\n\t(*rec).normal = select(-outward_normal, outward_normal, (*rec).frontFace);\n\t(*rec).material = materials[u32(sphere.material)];;\n\n\tvar theta = acos(-(*rec).position.y);\n\tvar phi = atan2(-(*rec).position.z, (*rec).position.x) + PI;\n\t(*rec).u = phi / (2.0 * PI);\n\t(*rec).v = theta / PI;\n\n\treturn true;\n}\n\nfn hitTriangle(triangle: Triangle, ray: Ray, tMin: f32, tMax: f32, rec: ptr<function, HitRecord>) -> bool {\n\tlet e0 = triangle.p1 - triangle.p0;\n    let e1 = triangle.p0 - triangle.p2;\n    let triangleNormal = cross( e1, e0 );\n\n\tlet e2 = ( 1.0 / dot( triangleNormal, ray.direction ) ) * ( triangle.p0 - ray.origin );\n    let i = cross( ray.direction, e2 );\n\n\tvar barycentricCoord = vec3f(0);\n    barycentricCoord.y = dot( i, e1 );\n    barycentricCoord.z = dot( i, e0 );\n    barycentricCoord.x = 1.0 - (barycentricCoord.z + barycentricCoord.y);\n    let hit = dot( triangleNormal, e2 );\n\n\tif(hit > tMax || hit < tMin){\n\t\treturn false;\n\t}\n\t\n\tif(barycentricCoord.x > 1 || barycentricCoord.x < 0||\n\t\tbarycentricCoord.y > 1 || barycentricCoord.y < 0|| \n\t\tbarycentricCoord.z > 1 || barycentricCoord.z < 0){\n\t\treturn false;\n\t}\n\n\tvar isFrontFace = dot(ray.direction, triangleNormal) < 0.;\n\t//if(!isFrontFace){\n\t//\treturn false;\n\t//}\n\n\t(*rec).distance = hit;\n\t(*rec).position = at(ray, (*rec).distance);\n\t(*rec).frontFace = isFrontFace;\n\t(*rec).normal = triangleNormal;\n\t(*rec).material = materials[u32(triangle.material)];\n\t(*rec).u = 0;\n\t(*rec).v = 0;\n\n    return true;\n}\n\n\nfn WorldHit(ray: Ray) -> HitRecord{\n\tvar rec = HitRecord(vec3(0.0),vec3(0.0), INFINITY, 0.0, 0.0, false, ground);\n\n\tvar spheresCount = arrayLength(&spheres);\n\tfor(var i: u32 = 0; i < spheresCount; i++){\n\t\thitSphere(spheres[i], ray, EPSILON, rec.distance, &rec);\n    }\n\tvar trianglesCount = arrayLength(&triangles);\n\tfor(var i: u32 = 0; i < trianglesCount; i++){\n\t\thitTriangle(triangles[i], ray, EPSILON, rec.distance, &rec);\n    }\n\t\t\n\tvar sphereLightsCount = arrayLength(&sphereLights);\n\tfor(var i: u32 = 0; i < sphereLightsCount; i++){\n\t\thitSphere(sphereLights[i], ray, EPSILON, rec.distance, &rec);\n    }\n\tvar triangleLightsCount = arrayLength(&triangleLights);\n\tfor(var i: u32 = 0; i < triangleLightsCount; i++){\n\t\thitTriangle(triangleLights[i], ray, EPSILON, rec.distance, &rec);\n    }\n\t\t\n\treturn rec;\t\n}\n\nfn directionToLight(light: Sphere, point: vec3f) -> vec3f {\n\treturn normalize(light.center + light.radius * random_in_unit_sphere(point.x) - point);\n}\n\nfn directionToTrianlgeLight(light: Triangle, point: vec3f) -> vec3f {\n\treturn normalize(random_in_specific_triangle(point.x, light.p0, light.p1, light.p2) - point);\n}\n\nfn LightHit(point: vec3f, normal: vec3f) -> vec3f {\n\tvar lightColor = vec3f(0);\n\tvar rec = HitRecord(vec3(0.0),vec3(0.0), INFINITY, 0.0, 0.0, false, ground);\n\n\tvar sphereLightsCount = arrayLength(&sphereLights);\n\tfor(var i: u32 = 0; i < sphereLightsCount; i++){\n\t\t\n\t\tvar ray = Ray(point, directionToLight(sphereLights[i], point));\n\t\t\n\t\tif(dot(normal, ray.direction) <= 0.0){\n\t\t\tcontinue;\n        }\n\t\t\n\t\trec = WorldHit(ray);\n        if(rec.material.emissive > 0){\n            lightColor += rec.material.color / pow(rec.distance, 2.0);\n        }\n\t}\n\t\n\tvar triangleLightsCount = arrayLength(&triangleLights);\n\tfor(var i: u32 = 0; i < triangleLightsCount; i++){\n\t\t\n\t\tvar directionToLight = directionToTrianlgeLight(triangleLights[i], point);\n\t\tvar ray = Ray(point, directionToLight);\n\t\t\n\t\tif(dot(normal, ray.direction) <= 0.0){\n\t\t\tcontinue;\n        }\n\n\t\tvar lightCosine = abs(normalize(directionToLight).y);\n\t\tif(lightCosine < EPSILON){\n\t\t\tcontinue;\n\t\t}\n\n\t\trec = WorldHit(ray);\n        if(rec.material.emissive > 0){ // todo if hitted different light\n            lightColor += rec.material.color / pow(rec.distance, 2.0) * lightCosine;\n        }\n\t}\n\n\treturn lightColor;\t\n}\n\nfn rayColor(_ray: Ray) -> vec3f {\n    var ray = _ray;\n\tvar rayColor = vec3(1.0);\n\tvar lightAdditive = vec3(0.0);\n\tvar totalDistance = 0.0;\n\n\tfor(var depth = 0; depth < MAXBOUNCES; depth++){\n\n\t\tvar rec = WorldHit(ray);\n\n\t\tif(rec.distance >= INFINITY){ // nothing hitted\n\t\t\trayColor = vec3f(0, 0, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tvar materialColor = rec.material.color;\n\t\tif(rec.material.texture == 0 && sin(16.0 * rec.position.x) * sin(16.0 * rec.position.z) < -0.0001){\n\t\t\tmaterialColor /= 8.0;\n        }\n\n\t\ttotalDistance += rec.distance;\n\n\t\tif(rec.material.emissive > 0){ // light\n\t\t\trayColor *= materialColor / pow(totalDistance, 2.0);\n\t\t\tlightAdditive += rayColor;\n\t\t\tbreak;\n\t\t}\n\t\tvar lightColor = LightHit(rec.position, rec.normal);\n\t\t\n\t\tif(rec.material.refraction == 0.0){ // todo, specular on glass is what we want\n\t\t\tlightAdditive += rayColor * lightColor * materialColor * (1.0 - rec.material.reflection);\n\t\t}\n\n\t\tvar nextRayDirection: vec3f;\n\t\tif(rec.material.refraction > 0.0){ // glass\n\t\t\tvar refraction_ratio = select(rec.material.refraction, 1.0 / rec.material.refraction, rec.frontFace);\n\t\t\tvar unit_direction = normalize(ray.direction);\n\t\t\tnextRayDirection = refract(unit_direction, rec.normal, refraction_ratio);\n\t\t} else{\n\t\t\t// mirror\n\t\t\tvar targetReflect = reflect(ray.direction, rec.normal);\n\t\t\t// diffuse\n\t\t\tvar targetDiffuse = random_in_hemisphere(rec.normal, rec.distance + f32(depth));\n\t\t\tif(rand(rec.distance + f32(depth)) < rec.material.reflection)\n\t\t\t{\n\t\t\t\tnextRayDirection = targetReflect;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnextRayDirection = targetDiffuse;\n\t\t\t}\n\t\t}\n\n\t\tray = Ray(rec.position, nextRayDirection);\n\t\trayColor *= materialColor;\n\t}\n\treturn lightAdditive;\n}\n\n// ########### Main ###########\n\n@fragment\nfn main(\n    @location(0) fragPosition: vec4f\n) -> @location(0) vec4f {\n\tcoordinates = fragPosition.xy * .05;\n    var tmpColor = vec3f(0.0);\n\tvar lookfrom = cameraPos;\n\tvar lookat = cameraLookAt;\n\tvar vup = vec3f(0, 1, 0);\n\tvar vfov = 60.0;\n\tvar aspect_ratio = resolution.x / resolution.y;\n\tvar aperture = 0.1;\n\tvar focus_dist = 10.0;\n\n\tvar  theta = radians(vfov);\n\tvar  h = tan(theta / 2.);\n\tvar  viewport_height = 2.0 * h;\n\tvar  viewport_width = aspect_ratio * viewport_height;\n\n\tvar w = normalize(lookfrom - lookat);\n\tvar u = normalize(cross(vup, w));\n\tvar v = cross(w, u);\n\n\tvar origin = lookfrom;\n\tvar horizontal = focus_dist * viewport_width * u;\n\tvar vertical = focus_dist * viewport_height * v;\n\tvar lower_left_corner = origin - horizontal / 2. - vertical / 2. - focus_dist * w;\n\n\tfor(var sampleI = 0; sampleI < SAMPLES; sampleI++){\n\t\tvar randomOffset = rand2(42.4 * f32(sampleI) + 3/iteration) / resolution;\n\t\trandomOffset += fragPosition.xy;\n\n\t\tvar ray = Ray(cameraPos, lower_left_corner + randomOffset.x * horizontal + randomOffset.y * vertical - cameraPos);\n\t\ttmpColor += rayColor(ray);\n\t}\n\n\tvar gamma = 2.2;\n\n\tvar current = pow(tmpColor / f32(SAMPLES), vec3f(1.0 / gamma));\n\t//current = clamp(current, vec3f(0), vec3f(1000)); // todo cheaty no fireflies\n\n\tvar previous = textureLoad(\n    \tpreviousFrame,\n    \tvec2<i32>((vec2(fragPosition.x,1-fragPosition.y)) * resolution.xy),\n    \t0\n  \t).xyz;\n\n\tcurrent = max(vec3f(0,0,0), current);\n\tvar finalColor = vec4(mix(previous, current, 1/iteration), 1.0);\n\n\ttextureStore(\n\t\tcurrentFrame,\n\t\tvec2<i32>((vec2(fragPosition.x,1-fragPosition.y)) * resolution.xy),\n\t\tfinalColor\t\t\n\t);\n\t\n\t//if(arrayLength(&spheres) == 1){\n\t//\treturn vec4f(0,1,0,1);\n\t//}else{\n\t//\treturn vec4f(1,0,0,1);\n\t//}\n\n\t//return vec4(vec3(rand(42.4)), 1);\n\treturn finalColor;\n}\n"}),entryPoint:"main",targets:[{format:f}]},primitive:{topology:"triangle-list"}})}(),window.addEventListener("keydown",B),window.addEventListener("keydown",U),window.addEventListener("keydown",L),window.addEventListener("resize",S),P(),x()}))})();